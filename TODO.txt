[ ] Refactor - Rolling changes 
[x] serve static directores based on a catch-all wildcard
[x] POST request handling (?id=10 paramerts in url)
[x] dynamic routes (/user/{uuid})
[x] Add unit tests for router
[x] Add integration tests
[x] HTTPS
[ ] Integration tests - internal server error and redirection server
[ ] Thread pool
[ ] IPv6
[ ] json response - need a json Reponse:: type similar to file::
[ ] Add Doxygen comments for public API (Use github action to automatically build and publish)
[ ] Compile as a proper library not just a local library
[ ] Python wrapper similar to FastAPI
[ ] Research how to host this server securly on a linux server (Do i need a domain, firewall etc...)
[ ] Use this server as a backend for serving a simple file storage website (Like google drive)
[ ] research man pages for sys calls used by server in order to make the socket setup better for deployment
[ ] interative readme and create proper github release actions

Further server enhancements:

ðŸ› ï¸ Production Readiness TODO

ðŸŸ¢ Phase 1 â€” Must-have hardening (High value, low risk)
	â€¢	Graceful shutdown / drain mode
	    â€¢	Add d_accepting flag to stop accepting new connections while allowing in-flight requests to finish
	    â€¢	Ensure accept loops exit cleanly without race conditions
	â€¢	Add send timeouts
	    â€¢	Set SO_SNDTIMEO alongside SO_RCVTIMEO
	    â€¢	Prevent blocking send() under backpressure or slow clients
	â€¢	Improve TLS error visibility
	    â€¢	Log OpenSSL error stack when SSL_accept() fails
	    â€¢	Use ERR_get_error() + ERR_error_string()
	â€¢	Limit concurrent connections
	    â€¢	Add maximum connection cap (e.g. kMaxConnections) or Thread Pool
	    â€¢	Reject new clients when limit is reached to avoid resource exhaustion

â¸»

ðŸŸ¡ Phase 2 â€” HTTP correctness & security
	â€¢	Proper HTTP request framing
	    â€¢	Accumulate input until full headers are received (\r\n\r\n)
	    â€¢	Do not assume entire request arrives in a single recv()
	â€¢	Enforce header and body size limits
	    â€¢	Add configurable limits:
	        â€¢	Max header size (e.g. 8â€“16 KB)
	        â€¢	Max body size (e.g. 1 MB)
	    â€¢	Reject oversized requests early
	â€¢	Strict handling of malformed requests
	    â€¢	Close connection on parse failure
	    â€¢	Ensure malformed input cannot trigger keep-alive reuse

â¸»

ðŸŸ¡ Phase 3 â€” Observability & diagnostics
	â€¢	Log remote client address
	    â€¢	Capture client IP/port at accept time
	    â€¢	Include in connection, error, and request logs
	â€¢	Improve log structure
	    â€¢	Standardize log fields (fd, IP, TLS, request path)
	    â€¢	Prepare for structured logging (even if logger remains simple)

â¸»

ðŸ”µ Phase 4 â€” Performance & scalability (Optional)
	â€¢	Thread pool for client handling
	    â€¢	Replace per-connection threads with a bounded worker pool
	    â€¢	Prevent thread explosion under load
	â€¢	Non-blocking I/O (epoll / kqueue)
	    â€¢	Only if high concurrency (>1k clients) is required
	    â€¢	Consider as a future rewrite, not an incremental change

â¸»

ðŸ”’ Phase 5 â€” TLS & security polish
	â€¢	Harden TLS configuration
	    â€¢	Disable legacy protocols (SSLv2, SSLv3, TLS 1.0/1.1)
	    â€¢	Consider restricted cipher suites
	â€¢	Basic rate limiting
	    â€¢	Limit:
	        â€¢	Connection attempts per IP
	        â€¢	Requests per connection
	        â€¢	Prevent abuse and simple DoS attacks

â¸»

ðŸ§ª Phase 6 â€” Testing & robustness
	â€¢	Fuzz HTTP parser
	    â€¢	Use libFuzzer / AFL against HttpParser::parse
	    â€¢	Catch crashes and edge cases early
	â€¢	Integration tests
	    â€¢	Plain HTTP
	    â€¢	HTTPS
	    â€¢	HTTP â†’ HTTPS redirection
	    â€¢	Keep-alive behavior
	    â€¢	Shutdown during active connections

